# coding: utf-8

"""
    NLD2 API

    The <b>NLD2 API</b> is a complete, programmable interface to all National Levee Database functionality. The NLD2 API is a RESTful web service, using standard technologies like HTTP verbs, headers, and status codes.<br/><br/>The <a href=\"/#/\" target=\"_blank\">National Levee Database website</a> is built on this API, and all of its services are available for integration into your application. To get started, we recommend exploring the website to learn about the functionality that is available and then using the OpenAPI specification below to try connecting to the test/hello endpoint.<br/><br/>Currently, you can develop your application with the public API. For more advanced features, you may need an NLD account and specific government clearance, depending on the nature of the data. If you need assistance, please email us at <a href=\"mailto:NLD@usace.army.mil\">NLD@usace.army.mil</a> or call us at <a href=\"tel:18775383387\">1-877-LEVEEUS</a> (1-877-538-3387).  # noqa: E501

    OpenAPI spec version: 3.26.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class FeaturesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def boreholes_id_get(self, id, **kwargs):  # noqa: E501
        """boreholes_id_get  # noqa: E501

        Gets a Borehole  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.boreholes_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Borehole (required)
        :return: Borehole2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.boreholes_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.boreholes_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def boreholes_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """boreholes_id_get  # noqa: E501

        Gets a Borehole  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.boreholes_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Borehole (required)
        :return: Borehole2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method boreholes_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `boreholes_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/boreholes/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Borehole2',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def centerlines_id_get(self, id, **kwargs):  # noqa: E501
        """centerlines_id_get  # noqa: E501

        Gets a Centerline  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.centerlines_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Centerline (required)
        :return: Centerline1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.centerlines_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.centerlines_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def centerlines_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """centerlines_id_get  # noqa: E501

        Gets a Centerline  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.centerlines_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Centerline (required)
        :return: Centerline1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method centerlines_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `centerlines_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/centerlines/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Centerline1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def channels_id_get(self, id, **kwargs):  # noqa: E501
        """channels_id_get  # noqa: E501

        Gets a Channel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Channel (required)
        :return: Channel1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.channels_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.channels_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def channels_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """channels_id_get  # noqa: E501

        Gets a Channel  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.channels_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Channel (required)
        :return: Channel1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method channels_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `channels_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/channels/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Channel1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def closure_structures_id_get(self, id, **kwargs):  # noqa: E501
        """closure_structures_id_get  # noqa: E501

        Gets a ClosureStructure  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.closure_structures_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of ClosureStructure (required)
        :return: ClosureStructure1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.closure_structures_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.closure_structures_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def closure_structures_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """closure_structures_id_get  # noqa: E501

        Gets a ClosureStructure  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.closure_structures_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of ClosureStructure (required)
        :return: ClosureStructure1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method closure_structures_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `closure_structures_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/closure-structures/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClosureStructure1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cross_sections_id_get(self, id, **kwargs):  # noqa: E501
        """cross_sections_id_get  # noqa: E501

        Gets a CrossSection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cross_sections_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of CrossSection (required)
        :return: CrossSection1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cross_sections_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.cross_sections_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def cross_sections_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """cross_sections_id_get  # noqa: E501

        Gets a CrossSection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cross_sections_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of CrossSection (required)
        :return: CrossSection1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cross_sections_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `cross_sections_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cross-sections/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CrossSection1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def floodwalls_id_get(self, id, **kwargs):  # noqa: E501
        """floodwalls_id_get  # noqa: E501

        Gets a Floodwall  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.floodwalls_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Floodwall (required)
        :return: Floodwall1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.floodwalls_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.floodwalls_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def floodwalls_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """floodwalls_id_get  # noqa: E501

        Gets a Floodwall  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.floodwalls_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Floodwall (required)
        :return: Floodwall1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method floodwalls_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `floodwalls_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/floodwalls/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Floodwall1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def frm_lines_id_get(self, id, **kwargs):  # noqa: E501
        """frm_lines_id_get  # noqa: E501

        Gets a FrmLine  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.frm_lines_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of FrmLine (required)
        :return: FrmLine1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.frm_lines_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.frm_lines_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def frm_lines_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """frm_lines_id_get  # noqa: E501

        Gets a FrmLine  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.frm_lines_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of FrmLine (required)
        :return: FrmLine1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method frm_lines_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `frm_lines_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/frm-lines/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FrmLine1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def geometries_type_id_get(self, type, id, **kwargs):  # noqa: E501
        """geometries_type_id_get  # noqa: E501

        Gets a geometry from a valid feature ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.geometries_type_id_get(type, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: The id of the geometry (required)
        :param int id: The id of the geometry (required)
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.geometries_type_id_get_with_http_info(type, id, **kwargs)  # noqa: E501
        else:
            (data) = self.geometries_type_id_get_with_http_info(type, id, **kwargs)  # noqa: E501
            return data

    def geometries_type_id_get_with_http_info(self, type, id, **kwargs):  # noqa: E501
        """geometries_type_id_get  # noqa: E501

        Gets a geometry from a valid feature ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.geometries_type_id_get_with_http_info(type, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: The id of the geometry (required)
        :param int id: The id of the geometry (required)
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'id', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method geometries_type_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'type' is set
        if self.api_client.client_side_validation and ('type' not in params or
                                                       params['type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `type` when calling `geometries_type_id_get`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `geometries_type_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/geometries/{type}/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alignment_line(self, id, **kwargs):  # noqa: E501
        """get_alignment_line  # noqa: E501

        Gets a Alignment Line  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alignment_line(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Alignment Line (required)
        :return: HsipLayer1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alignment_line_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_alignment_line_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_alignment_line_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_alignment_line  # noqa: E501

        Gets a Alignment Line  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alignment_line_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Alignment Line (required)
        :return: HsipLayer1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alignment_line" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `get_alignment_line`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/alignment-lines/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='HsipLayer1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_alignment_lines(self, **kwargs):  # noqa: E501
        """get_all_alignment_lines  # noqa: E501

        Gets all Alignment Lines  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_alignment_lines(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :return: list[HsipLayer1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_alignment_lines_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_alignment_lines_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_alignment_lines_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_alignment_lines  # noqa: E501

        Gets all Alignment Lines  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_alignment_lines_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :return: list[HsipLayer1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_alignment_lines" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/alignment-lines', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[HsipLayer1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_boreholes(self, **kwargs):  # noqa: E501
        """get_all_boreholes  # noqa: E501

        Gets all Boreholes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_boreholes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[Borehole1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_boreholes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_boreholes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_boreholes_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_boreholes  # noqa: E501

        Gets all Boreholes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_boreholes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[Borehole1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_boreholes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/boreholes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Borehole1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_channels(self, **kwargs):  # noqa: E501
        """get_all_channels  # noqa: E501

        Gets all Channels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_channels(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[Channel1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_channels_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_channels_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_channels_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_channels  # noqa: E501

        Gets all Channels  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_channels_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[Channel1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_channels" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/channels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Channel1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_closure_structures(self, **kwargs):  # noqa: E501
        """get_all_closure_structures  # noqa: E501

        Gets all ClosureStructures  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_closure_structures(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[ClosureStructure1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_closure_structures_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_closure_structures_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_closure_structures_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_closure_structures  # noqa: E501

        Gets all ClosureStructures  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_closure_structures_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[ClosureStructure1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_closure_structures" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/closure-structures', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ClosureStructure1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_cross_sections(self, **kwargs):  # noqa: E501
        """get_all_cross_sections  # noqa: E501

        Gets all CrossSections  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_cross_sections(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[CrossSection1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_cross_sections_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_cross_sections_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_cross_sections_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_cross_sections  # noqa: E501

        Gets all CrossSections  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_cross_sections_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[CrossSection1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_cross_sections" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/cross-sections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CrossSection1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_floodwalls(self, **kwargs):  # noqa: E501
        """get_all_floodwalls  # noqa: E501

        Gets all Floodwalls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_floodwalls(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[Floodwall1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_floodwalls_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_floodwalls_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_floodwalls_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_floodwalls  # noqa: E501

        Gets all Floodwalls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_floodwalls_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[Floodwall1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_floodwalls" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/floodwalls', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Floodwall1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_frm_lines(self, **kwargs):  # noqa: E501
        """get_all_frm_lines  # noqa: E501

        Gets all FRM Lines  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_frm_lines(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[FrmLine1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_frm_lines_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_frm_lines_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_frm_lines_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_frm_lines  # noqa: E501

        Gets all FRM Lines  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_frm_lines_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[FrmLine1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_frm_lines" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/frm-lines', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FrmLine1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_gravity_drains(self, **kwargs):  # noqa: E501
        """get_all_gravity_drains  # noqa: E501

        Gets all GravityDrains  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_gravity_drains(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[GravityDrain1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_gravity_drains_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_gravity_drains_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_gravity_drains_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_gravity_drains  # noqa: E501

        Gets all GravityDrains  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_gravity_drains_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[GravityDrain1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_gravity_drains" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/gravity-drains', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GravityDrain1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_levee_centerlines(self, **kwargs):  # noqa: E501
        """get_all_levee_centerlines  # noqa: E501

        Gets all LeveeCenterlines  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_levee_centerlines(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[Centerline1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_levee_centerlines_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_levee_centerlines_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_levee_centerlines_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_levee_centerlines  # noqa: E501

        Gets all LeveeCenterlines  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_levee_centerlines_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[Centerline1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_levee_centerlines" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/centerlines', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Centerline1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_levee_crossings(self, **kwargs):  # noqa: E501
        """get_all_levee_crossings  # noqa: E501

        Gets all LeveeCrossings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_levee_crossings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[LeveeCrossing1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_levee_crossings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_levee_crossings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_levee_crossings_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_levee_crossings  # noqa: E501

        Gets all LeveeCrossings  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_levee_crossings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[LeveeCrossing1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_levee_crossings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/levee-crossings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LeveeCrossing1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_levee_stations(self, **kwargs):  # noqa: E501
        """get_all_levee_stations  # noqa: E501

        Gets all LeveeStations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_levee_stations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[LeveeStation1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_levee_stations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_levee_stations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_levee_stations_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_levee_stations  # noqa: E501

        Gets all LeveeStations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_levee_stations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[LeveeStation1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_levee_stations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/levee-stations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LeveeStation1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_leveed_areas(self, **kwargs):  # noqa: E501
        """get_all_leveed_areas  # noqa: E501

        Gets all LeveedAreas  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_leveed_areas(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :return: list[LeveedArea1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_leveed_areas_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_leveed_areas_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_leveed_areas_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_leveed_areas  # noqa: E501

        Gets all LeveedAreas  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_leveed_areas_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :return: list[LeveedArea1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'embed', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_leveed_areas" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/leveed-areas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LeveedArea1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_piezometers(self, **kwargs):  # noqa: E501
        """get_all_piezometers  # noqa: E501

        Gets all Piezometers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_piezometers(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[Piezometer1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_piezometers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_piezometers_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_piezometers_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_piezometers  # noqa: E501

        Gets all Piezometers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_piezometers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[Piezometer1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_piezometers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/piezometers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Piezometer1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_pipe_gates(self, **kwargs):  # noqa: E501
        """get_all_pipe_gates  # noqa: E501

        Gets all Pipe Gates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_pipe_gates(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[PipeGate1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_pipe_gates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_pipe_gates_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_pipe_gates_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_pipe_gates  # noqa: E501

        Gets all Pipe Gates  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_pipe_gates_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[PipeGate1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_pipe_gates" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/pipe-gates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PipeGate1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_pipes(self, **kwargs):  # noqa: E501
        """get_all_pipes  # noqa: E501

        Gets all Pipes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_pipes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[Pipe1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_pipes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_pipes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_pipes_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_pipes  # noqa: E501

        Gets all Pipes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_pipes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[Pipe1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_pipes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/pipes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Pipe1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_pump_stations(self, **kwargs):  # noqa: E501
        """get_all_pump_stations  # noqa: E501

        Gets all PumpStations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_pump_stations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[PumpStation1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_pump_stations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_pump_stations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_pump_stations_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_pump_stations  # noqa: E501

        Gets all PumpStations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_pump_stations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[PumpStation1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_pump_stations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/pump-stations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PumpStation1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_relief_wells(self, **kwargs):  # noqa: E501
        """get_all_relief_wells  # noqa: E501

        Gets all ReliefWells  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_relief_wells(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[ReliefWell1]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_relief_wells_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_relief_wells_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_relief_wells_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_relief_wells  # noqa: E501

        Gets all ReliefWells  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_relief_wells_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties
        :return: list[ReliefWell1]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_relief_wells" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/relief-wells', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReliefWell1]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_toedrains(self, **kwargs):  # noqa: E501
        """get_all_toedrains  # noqa: E501

        Gets all Toedrains  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_toedrains(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_toedrains_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_toedrains_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_toedrains_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_toedrains  # noqa: E501

        Gets all Toedrains  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_toedrains_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: systemId
        :param int segment_id: segmentId
        :param str embed: link to embed
        :param str format: JSON geometry format (topo, geo). Default is topo
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id', 'segment_id', 'embed', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_toedrains" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'system_id' in params:
            query_params.append(('system_id', params['system_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'embed' in params:
            query_params.append(('embed', params['embed']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/toedrains', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[object]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_geo_json_feature_collection(self, system_id, **kwargs):  # noqa: E501
        """get_geo_json_feature_collection  # noqa: E501

        Gets all leveed areas belonging to system as a geojson feature collection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_geo_json_feature_collection(system_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: system_id (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_geo_json_feature_collection_with_http_info(system_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_geo_json_feature_collection_with_http_info(system_id, **kwargs)  # noqa: E501
            return data

    def get_geo_json_feature_collection_with_http_info(self, system_id, **kwargs):  # noqa: E501
        """get_geo_json_feature_collection  # noqa: E501

        Gets all leveed areas belonging to system as a geojson feature collection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_geo_json_feature_collection_with_http_info(system_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int system_id: system_id (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['system_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_geo_json_feature_collection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'system_id' is set
        if self.api_client.client_side_validation and ('system_id' not in params or
                                                       params['system_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `system_id` when calling `get_geo_json_feature_collection`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'system_id' in params:
            path_params['systemId'] = params['system_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/leveed-areas-{systemId}.geojson', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_geo_json_feature_collection_0(self, segment_id, **kwargs):  # noqa: E501
        """get_geo_json_feature_collection_0  # noqa: E501

        Gets all levee stations belonging to segment as a geojson feature collection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_geo_json_feature_collection_0(segment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int segment_id: segment_id (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_geo_json_feature_collection_0_with_http_info(segment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_geo_json_feature_collection_0_with_http_info(segment_id, **kwargs)  # noqa: E501
            return data

    def get_geo_json_feature_collection_0_with_http_info(self, segment_id, **kwargs):  # noqa: E501
        """get_geo_json_feature_collection_0  # noqa: E501

        Gets all levee stations belonging to segment as a geojson feature collection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_geo_json_feature_collection_0_with_http_info(segment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int segment_id: segment_id (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['segment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_geo_json_feature_collection_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'segment_id' is set
        if self.api_client.client_side_validation and ('segment_id' not in params or
                                                       params['segment_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `segment_id` when calling `get_geo_json_feature_collection_0`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'segment_id' in params:
            path_params['segmentId'] = params['segment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/levee-stations-{segmentId}.geojson', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_some(self, type, **kwargs):  # noqa: E501
        """get_some  # noqa: E501

        Gets geometries by type and system/segment Id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_some(type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: The type (or class) of the geometry in spinal case (e.g. pump-station) (required)
        :param int segment_id: The segment id of the geometry (one of systemId or segmentId is required)
        :param int system_id: The system id of the geometry (one of systemId or segmentId is required)
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties (id, name, class)
        :param bool coll: Return response as a FeatureCollection
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_some_with_http_info(type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_some_with_http_info(type, **kwargs)  # noqa: E501
            return data

    def get_some_with_http_info(self, type, **kwargs):  # noqa: E501
        """get_some  # noqa: E501

        Gets geometries by type and system/segment Id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_some_with_http_info(type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: The type (or class) of the geometry in spinal case (e.g. pump-station) (required)
        :param int segment_id: The segment id of the geometry (one of systemId or segmentId is required)
        :param int system_id: The system id of the geometry (one of systemId or segmentId is required)
        :param str format: JSON geometry format (topo, geo). Default is topo
        :param bool props: Include identifying properties (id, name, class)
        :param bool coll: Return response as a FeatureCollection
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'segment_id', 'system_id', 'format', 'props', 'coll']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_some" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'type' is set
        if self.api_client.client_side_validation and ('type' not in params or
                                                       params['type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `type` when calling `get_some`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segmentId', params['segment_id']))  # noqa: E501
        if 'system_id' in params:
            query_params.append(('systemId', params['system_id']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501
        if 'coll' in params:
            query_params.append(('coll', params['coll']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/geometries/query', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gravity_drains_id_get(self, id, **kwargs):  # noqa: E501
        """gravity_drains_id_get  # noqa: E501

        Gets a GravityDrain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gravity_drains_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of GravityDrain (required)
        :return: GravityDrain1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gravity_drains_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.gravity_drains_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def gravity_drains_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """gravity_drains_id_get  # noqa: E501

        Gets a GravityDrain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gravity_drains_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of GravityDrain (required)
        :return: GravityDrain1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gravity_drains_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `gravity_drains_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/gravity-drains/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GravityDrain1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def levee_crossings_id_get(self, id, **kwargs):  # noqa: E501
        """levee_crossings_id_get  # noqa: E501

        Gets a LeveeCrossing  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.levee_crossings_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of LeveeCrossing (required)
        :return: LeveeCrossing1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.levee_crossings_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.levee_crossings_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def levee_crossings_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """levee_crossings_id_get  # noqa: E501

        Gets a LeveeCrossing  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.levee_crossings_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of LeveeCrossing (required)
        :return: LeveeCrossing1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method levee_crossings_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `levee_crossings_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/levee-crossings/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LeveeCrossing1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def levee_stations_id_get(self, id, **kwargs):  # noqa: E501
        """levee_stations_id_get  # noqa: E501

        Gets a LeveeStation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.levee_stations_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of LeveeStation (required)
        :return: LeveeStation1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.levee_stations_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.levee_stations_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def levee_stations_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """levee_stations_id_get  # noqa: E501

        Gets a LeveeStation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.levee_stations_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of LeveeStation (required)
        :return: LeveeStation1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method levee_stations_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `levee_stations_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/levee-stations/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LeveeStation1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def leveed_areas_id_get(self, id, **kwargs):  # noqa: E501
        """leveed_areas_id_get  # noqa: E501

        Gets a LeveedArea  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.leveed_areas_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of LeveedArea (required)
        :return: LeveedArea1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.leveed_areas_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.leveed_areas_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def leveed_areas_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """leveed_areas_id_get  # noqa: E501

        Gets a LeveedArea  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.leveed_areas_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of LeveedArea (required)
        :return: LeveedArea1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method leveed_areas_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `leveed_areas_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/leveed-areas/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LeveedArea1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def piezometers_id_get(self, id, **kwargs):  # noqa: E501
        """piezometers_id_get  # noqa: E501

        Gets a Piezometer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.piezometers_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Piezometer (required)
        :return: Piezometer1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.piezometers_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.piezometers_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def piezometers_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """piezometers_id_get  # noqa: E501

        Gets a Piezometer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.piezometers_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Piezometer (required)
        :return: Piezometer1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method piezometers_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `piezometers_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/piezometers/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Piezometer1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pipe_gates_id_get(self, id, **kwargs):  # noqa: E501
        """pipe_gates_id_get  # noqa: E501

        Gets a PipeGate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pipe_gates_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of PipeGate (required)
        :return: PipeGate1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pipe_gates_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.pipe_gates_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def pipe_gates_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """pipe_gates_id_get  # noqa: E501

        Gets a PipeGate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pipe_gates_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of PipeGate (required)
        :return: PipeGate1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipe_gates_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `pipe_gates_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/pipe-gates/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PipeGate1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pipes_id_get(self, id, **kwargs):  # noqa: E501
        """pipes_id_get  # noqa: E501

        Gets a Pipe  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pipes_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Pipe (required)
        :return: Pipe1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pipes_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.pipes_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def pipes_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """pipes_id_get  # noqa: E501

        Gets a Pipe  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pipes_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Pipe (required)
        :return: Pipe1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pipes_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `pipes_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/pipes/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Pipe1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pump_stations_id_get(self, id, **kwargs):  # noqa: E501
        """pump_stations_id_get  # noqa: E501

        Gets a PumpStation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pump_stations_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of PumpStation (required)
        :return: PumpStation1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pump_stations_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.pump_stations_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def pump_stations_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """pump_stations_id_get  # noqa: E501

        Gets a PumpStation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pump_stations_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of PumpStation (required)
        :return: PumpStation1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pump_stations_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `pump_stations_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/pump-stations/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PumpStation1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def relief_wells_id_get(self, id, **kwargs):  # noqa: E501
        """relief_wells_id_get  # noqa: E501

        Gets a ReliefWell  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.relief_wells_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of ReliefWell (required)
        :return: ReliefWell1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.relief_wells_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.relief_wells_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def relief_wells_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """relief_wells_id_get  # noqa: E501

        Gets a ReliefWell  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.relief_wells_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of ReliefWell (required)
        :return: ReliefWell1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method relief_wells_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `relief_wells_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/relief-wells/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReliefWell1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def toedrains_id_get(self, id, **kwargs):  # noqa: E501
        """toedrains_id_get  # noqa: E501

        Gets a Toedrain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.toedrains_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Toedrain (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.toedrains_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.toedrains_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def toedrains_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """toedrains_id_get  # noqa: E501

        Gets a Toedrain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.toedrains_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: ID of Toedrain (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method toedrains_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `toedrains_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/toedrains/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
